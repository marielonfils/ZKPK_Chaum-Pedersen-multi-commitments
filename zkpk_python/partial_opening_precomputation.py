import numpy as np
from utils.group import random_exp, compute_size3,PowRadix
from utils.hash2 import hash_elems
from extended_schnorr import extended_schnorr_proof, extended_schnorr_verification
from utils.constants import generate_constants,h,u,p,q 
from gmpy2 import powmod as pow,mpz

### Implementation of the Partial Opening protocol ###

# groups size
l=8+1 # power of 2 +1

#precomputation parmeter
k=2

# generators
gs = generate_constants(l)
gs_radix = [PowRadix(gs[i], k) for i in range(l)]
gspow = [gs_radix[i].pow for i in range(l)]
h_radix = PowRadix(h, k) 
hpow = h_radix.pow

# votes and commitment on votes
index_j=np.random.randint(l)
vs=np.random.randint(2,size=(l))
bit=vs[index_j]
V=mpz(1)
gamma=random_exp()
V = V*hpow(gamma) #V*pow(h,gamma,p)%p
for j in range(l):    
    V = V*gspow[j](mpz(vs[j]))%p #V *pow(gs[j],mpz(vs[j]),p)%p


# find index corresponding to i (index in array where indexx_j removed) in the original array
def find_index(i,index_j):
    if i<index_j:
        return i
    else:
        return i+1

#Prover's function
def generate_proof(gs,h,u,V,index_j,bit,vs,gamma):
    """
    Provides a proof that the commitment V are well formed and that v_j = vs[index_j]
    inputs
        - gs : array of mpz of size l containing generators 
        - hs : array of mpz of size l containing generators 
        - h : mpz generator 
        - u : mpz generator
        - V : array of mpz of size m containing the commitments on the l possible selections
        - index_j : int, between 0 and l-1
        - bit : mpz, value of vs[index_j] 
        - vs : array of mpz of size lxm containing the votes as 0/1
        - gammas : array of mpz of size m containing the randomness to create the commitments Vs
        Note that l should be a power of 2.
    outputs
        - S : element of G
        - mu : elment of Z_p
        - e : elements generated by the Extended Schnorr argument
    """


    #step 0#
    g_bolds=np.delete(gs,index_j)

    #step 1#
    #1.1
    vs_tilde=np.delete(vs,index_j)
    #1.2
    alpha=random_exp()
    ss=np.zeros(l-1,dtype=object)
    for i in range(l-1):
        ss[i]=random_exp()
    #1.3
    S= hpow(alpha) #pow(h,alpha,p)
    for i in range(l-1):
        S = S*gspow[find_index(i,index_j)](ss[i])%p  #S * pow(g_bolds[i],ss[i],p)%p
    
    #step 2 - 3 - 4#
    x=mpz(hash_elems(S,gs,h,u,V,index_j,bit,q=q))
    rand=0
    while x==0:
        x=mpz(hash_elems(S,gs,h,u,V,index_j,bit,rand,q=q))
        rand+=1
    
    #step 5
    #5.1
    mu = (gamma+alpha*x%q)%q
    #5.2
    bs=np.zeros(l-1,dtype=object)
    for i in range(l-1):
        bs[i] = (vs_tilde[i]+ss[i]*x%q)%q
   
    #step 7#
    P = hpow(q-mu)*pow(S,x,p)%p*V%p*gspow[index_j](q-bit)%p#pow(h,q-mu,p)*pow(S,x,p)%p*V%p*pow(gs[index_j],q-bit,p)%p
     
    #step 8#
    e=extended_schnorr_proof(g_bolds,P,bs,p,q)  
    return S,mu,e
    

#Verifier's function
def verify_proof(gs,h,u,V,index_j,bit,S,mu,e):
    """
    Verifies that the commitment V is well formed and that v_j = vs[index_j]
    inputs 
        - gs : array of mpz of size l containing generators 
        - h : mpz generator 
        - u : mpz generator
        - V : array of mpz of size m containing the commitments on the l possible selections
        - index_j : int, between 0 and l-1
        - bit : mpz, value of vs[index_j]
        - S : element of G
        - mu : elment of Z_p
        - e : elements generated by the Extended Schnorr argument
        Note that l should be a power of 2.
    outputs
        - 0 : success
        - 1 : error in the Extended Schnorr argument
    """

    x=mpz(hash_elems(S,gs,h,u,V,index_j,bit,q=q))
    rand=0
    while x==0:
        x=mpz(hash_elems(S,gs,h,u,V,index_j,bit,rand,q=q))
        rand+=1

    #step 0#
    g_bolds = np.delete(gs,index_j)

    #step 7#
    P=hpow(q-mu)*pow(S,x,p)%p*V%p*gspow[index_j](q-bit)%p #pow(h,q-mu,p)*pow(S,x,p)%p*V%p*pow(gs[index_j],q-bit,p)%p  

    #step 8#
    a_e,Ls_e,Rs_e=e
    if not extended_schnorr_verification(g_bolds,P,a_e,Ls_e,Rs_e,p,q):
        return 1
    return 0

S,mu,e=generate_proof(gs,h,u,V,index_j,bit,vs,gamma)
t=verify_proof(gs,h,u,V,index_j,bit,S,mu,e)
print(t)
