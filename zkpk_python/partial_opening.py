import numpy as np
from utils.group import random_exp, compute_size3
from utils.hash2 import hash_elems
from extended_schnorr import extended_schnorr_proof, extended_schnorr_verification
from utils.constants import generate_constants,h,u,p,q 
from gmpy2 import powmod as pow,mpz


### Implementation of the Partial Opening protocol ###

# groups size
l=8+1 # power of 2 +1

# generators
gs = generate_constants(l)


# votes and commitment on votes
index_j=np.random.randint(l)
vs=np.random.randint(2,size=(l))
bit=vs[index_j]
V=mpz(1)
gamma=random_exp()
V = V*pow(h,gamma,p)%p
for j in range(l):    
    V = V *pow(gs[j],mpz(vs[j]),p)%p


#Prover's function
def generate_proof(gs,h,u,V,index_j,bit,vs,gamma):
    """
    Provides a proof that the commitment V are well formed and that v_j = vs[index_j]
    inputs
        - gs : array of mpz of size l containing generators 
        - hs : array of mpz of size l containing generators 
        - h : mpz generator 
        - u : mpz generator
        - V : array of mpz of size m containing the commitments on the l possible selections
        - index_j : int, between 0 and l-1
        - bit : mpz, value of vs[index_j] 
        - vs : array of mpz of size lxm containing the votes as 0/1
        - gammas : array of mpz of size m containing the randomness to create the commitments Vs
        Note that l should be a power of 2.
    outputs
        - S : element of G
        - mu : elment of Z_p
        - e : elements generated by the Extended Schnorr argument
    """


    #step 0#
    g_bolds=np.delete(gs,index_j)

    #step 1#
    #1.1
    vs_tilde=np.delete(vs,index_j)
    #1.2
    alpha=random_exp()
    ss=np.zeros(l-1,dtype=object)
    for i in range(l-1):
        ss[i]=random_exp()
    #1.3
    S=pow(h,alpha,p)
    for i in range(l-1):
        S = S * pow(g_bolds[i],ss[i],p)%p
    
    #step 2 - 3 - 4#
    x=mpz(hash_elems(S,gs,h,u,V,index_j,bit,q=q))
    rand=0
    while x==0:
        x=mpz(hash_elems(S,gs,h,u,V,index_j,bit,rand,q=q))
        rand+=1
    
    #step 5
    #5.1
    mu = (gamma+alpha*x%q)%q
    #5.2
    bs=np.zeros(l-1,dtype=object)
    for i in range(l-1):
        bs[i] = (vs_tilde[i]+ss[i]*x%q)%q
   
    #step 7#
    P = pow(h,q-mu,p)*pow(S,x,p)%p*V%p*pow(gs[index_j],q-bit,p)%p
     
    #step 8#
    e=extended_schnorr_proof(g_bolds,P,bs,p,q)  
    return S,mu,e
    

#Verifier's function
def verify_proof(gs,h,u,V,index_j,bit,S,mu,e):
    """
    Verifies that the commitment V is well formed and that v_j = vs[index_j]
    inputs 
        - gs : array of mpz of size l containing generators 
        - h : mpz generator 
        - u : mpz generator
        - V : array of mpz of size m containing the commitments on the l possible selections
        - index_j : int, between 0 and l-1
        - bit : mpz, value of vs[index_j]
        - S : element of G
        - mu : elment of Z_p
        - e : elements generated by the Extended Schnorr argument
        Note that l should be a power of 2.
    outputs
        - 0 : success
        - 1 : error in the Extended Schnorr argument
    """

    x=mpz(hash_elems(S,gs,h,u,V,index_j,bit,q=q))
    rand=0
    while x==0:
        x=mpz(hash_elems(S,gs,h,u,V,index_j,bit,rand,q=q))
        rand+=1

    #step 0#
    g_bolds = np.delete(gs,index_j)

    #step 7#
    P=pow(h,q-mu,p)*pow(S,x,p)%p*V%p*pow(gs[index_j],q-bit,p)%p  

    #step 8#
    a_e,Ls_e,Rs_e=e
    if not extended_schnorr_verification(g_bolds,P,a_e,Ls_e,Rs_e,p,q):
        return 1
    return 0


S,mu,e=generate_proof(gs,h,u,V,index_j,bit,vs,gamma)
t=verify_proof(gs,h,u,V,index_j,bit,S,mu,e)
print(t)